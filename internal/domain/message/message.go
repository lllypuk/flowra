package message

import (
	"time"

	"github.com/lllypuk/flowra/internal/domain/errs"
	"github.com/lllypuk/flowra/internal/domain/uuid"
)

// Type represents the source/nature of a message
type Type string

const (
	// TypeUser is a message typed by a user
	TypeUser Type = "user"
	// TypeSystem is a message generated by the system (from UI actions)
	TypeSystem Type = "system"
	// TypeBot is a response from the bot (tag processing results)
	TypeBot Type = "bot"
)

// Message represents message in chate
type Message struct {
	id              uuid.UUID
	chatID          uuid.UUID
	authorID        uuid.UUID
	content         string
	msgType         Type       // message type
	actorID         *uuid.UUID // who initiated (for system messages)
	parentMessageID uuid.UUID  // for tredov
	createdAt       time.Time
	editedAt        *time.Time
	isDeleted       bool
	deletedAt       *time.Time
	attachments     []Attachment
	reactions       []Reaction
}

// NewMessage creates new message (defaults to TypeUser)
func NewMessage(
	chatID uuid.UUID,
	authorID uuid.UUID,
	content string,
	parentMessageID uuid.UUID,
) (*Message, error) {
	return NewMessageWithType(chatID, authorID, content, parentMessageID, TypeUser, nil)
}

// NewMessageWithType creates a message with specified type
func NewMessageWithType(
	chatID uuid.UUID,
	authorID uuid.UUID,
	content string,
	parentMessageID uuid.UUID,
	msgType Type,
	actorID *uuid.UUID,
) (*Message, error) {
	if chatID.IsZero() {
		return nil, errs.ErrInvalidInput
	}
	if authorID.IsZero() {
		return nil, errs.ErrInvalidInput
	}
	if content == "" && msgType != TypeSystem {
		return nil, errs.ErrInvalidInput
	}

	// Default to TypeUser if not specified
	if msgType == "" {
		msgType = TypeUser
	}

	return &Message{
		id:              uuid.NewUUID(),
		chatID:          chatID,
		authorID:        authorID,
		content:         content,
		msgType:         msgType,
		actorID:         actorID,
		parentMessageID: parentMessageID,
		createdAt:       time.Now(),
		isDeleted:       false,
		attachments:     make([]Attachment, 0),
		reactions:       make([]Reaction, 0),
	}, nil
}

// Reconstruct reconstructs message from save.
// Used by repositories for hydration obekta without validation business rules.
// all parameters dolzhny byt valid values from save.
func Reconstruct(
	id uuid.UUID,
	chatID uuid.UUID,
	authorID uuid.UUID,
	content string,
	parentMessageID uuid.UUID,
	createdAt time.Time,
	editedAt *time.Time,
	isDeleted bool,
	deletedAt *time.Time,
	attachments []Attachment,
	reactions []Reaction,
	msgType Type,
	actorID *uuid.UUID,
) *Message {
	if attachments == nil {
		attachments = make([]Attachment, 0)
	}
	if reactions == nil {
		reactions = make([]Reaction, 0)
	}
	// Default to TypeUser if not specified
	if msgType == "" {
		msgType = TypeUser
	}

	return &Message{
		id:              id,
		chatID:          chatID,
		authorID:        authorID,
		content:         content,
		msgType:         msgType,
		actorID:         actorID,
		parentMessageID: parentMessageID,
		createdAt:       createdAt,
		editedAt:        editedAt,
		isDeleted:       isDeleted,
		deletedAt:       deletedAt,
		attachments:     attachments,
		reactions:       reactions,
	}
}

// EditContent redaktiruet soderzhimoe messages
func (m *Message) EditContent(newContent string, editorID uuid.UUID) error {
	if m.isDeleted {
		return errs.ErrInvalidState
	}
	if newContent == "" {
		return errs.ErrInvalidInput
	}
	if !m.CanBeEditedBy(editorID) {
		return errs.ErrForbidden
	}

	m.content = newContent
	now := time.Now()
	m.editedAt = &now
	return nil
}

// Delete myagko udalyaet message
func (m *Message) Delete(deleterID uuid.UUID) error {
	if m.isDeleted {
		return errs.ErrInvalidState
	}
	if !m.CanBeEditedBy(deleterID) {
		return errs.ErrForbidden
	}

	m.isDeleted = true
	now := time.Now()
	m.deletedAt = &now
	return nil
}

// AddReaction adds reaction
func (m *Message) AddReaction(userID uuid.UUID, emojiCode string) error {
	if m.isDeleted {
		return errs.ErrInvalidState
	}
	if m.HasReaction(userID, emojiCode) {
		return errs.ErrAlreadyExists
	}

	reaction, err := NewReaction(userID, emojiCode)
	if err != nil {
		return err
	}

	m.reactions = append(m.reactions, reaction)
	return nil
}

// RemoveReaction udalyaet reaction
func (m *Message) RemoveReaction(userID uuid.UUID, emojiCode string) error {
	if !m.HasReaction(userID, emojiCode) {
		return errs.ErrNotFound
	}

	newReactions := make([]Reaction, 0, len(m.reactions)-1)
	for _, r := range m.reactions {
		if r.UserID() != userID || r.EmojiCode() != emojiCode {
			newReactions = append(newReactions, r)
		}
	}
	m.reactions = newReactions
	return nil
}

// AddAttachment adds attachment
func (m *Message) AddAttachment(fileID uuid.UUID, fileName string, fileSize int64, mimeType string) error {
	if m.isDeleted {
		return errs.ErrInvalidState
	}

	attachment, err := NewAttachment(fileID, fileName, fileSize, mimeType)
	if err != nil {
		return err
	}

	m.attachments = append(m.attachments, attachment)
	return nil
}

// HasReaction checks presence reaktsii ot user
func (m *Message) HasReaction(userID uuid.UUID, emojiCode string) bool {
	for _, r := range m.reactions {
		if r.UserID() == userID && r.EmojiCode() == emojiCode {
			return true
		}
	}
	return false
}

// CanBeEditedBy checks if user can edit message
func (m *Message) CanBeEditedBy(userID uuid.UUID) bool {
	return m.authorID == userID
}

// IsEdited checks if message was edited
func (m *Message) IsEdited() bool {
	return m.editedAt != nil
}

// IsReply checks, is is message a reply (in thread)
func (m *Message) IsReply() bool {
	return !m.parentMessageID.IsZero()
}

// GetReactionCount returns count of reactions specific type
func (m *Message) GetReactionCount(emojiCode string) int {
	count := 0
	for _, r := range m.reactions {
		if r.EmojiCode() == emojiCode {
			count++
		}
	}
	return count
}

// Getters

// ID returns ID messages
func (m *Message) ID() uuid.UUID {
	return m.id
}

// ChatID returns ID chat
func (m *Message) ChatID() uuid.UUID {
	return m.chatID
}

// AuthorID returns ID avtora
func (m *Message) AuthorID() uuid.UUID {
	return m.authorID
}

// Content returns soderzhimoe messages
func (m *Message) Content() string {
	return m.content
}

// ParentMessageID returns ID roditelskogo messages (for tredov)
func (m *Message) ParentMessageID() uuid.UUID {
	return m.parentMessageID
}

// CreatedAt returns creation time
func (m *Message) CreatedAt() time.Time {
	return m.createdAt
}

// EditedAt returns time redaktirovaniya
func (m *Message) EditedAt() *time.Time {
	return m.editedAt
}

// IsDeleted returns flag removing
func (m *Message) IsDeleted() bool {
	return m.isDeleted
}

// DeletedAt returns time removing
func (m *Message) DeletedAt() *time.Time {
	return m.deletedAt
}

// Attachments returns kopiyu list vlozheniy
func (m *Message) Attachments() []Attachment {
	attachments := make([]Attachment, len(m.attachments))
	copy(attachments, m.attachments)
	return attachments
}

// Reactions returns kopiyu list reactions
func (m *Message) Reactions() []Reaction {
	reactions := make([]Reaction, len(m.reactions))
	copy(reactions, m.reactions)
	return reactions
}

// Type returns the message type
func (m *Message) Type() Type {
	return m.msgType
}

// ActorID returns the actor who initiated this message (for system messages)
func (m *Message) ActorID() *uuid.UUID {
	return m.actorID
}

// IsSystemMessage returns true if this is a system-generated message
func (m *Message) IsSystemMessage() bool {
	return m.msgType == TypeSystem
}

// IsBotMessage returns true if this is a bot-generated message
func (m *Message) IsBotMessage() bool {
	return m.msgType == TypeBot
}
