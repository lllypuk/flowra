# Task 07.3: Chat Aggregate Methods

**Статус:** ✅ Completed
**Приоритет:** High
**Зависимости:** Task 07.1, Task 07.2
**Оценка:** 1 день

## Описание

Реализовать методы Chat aggregate для всех tag операций. Методы должны выполнять бизнес-логику, валидацию, создавать и применять события.

## Контекст

В проекте уже есть:
- `internal/domain/chat/chat.go` - Chat aggregate с базовыми методами
- Существующий метод `ConvertToTask(newType Type, title string)` - нужно расширить
- Event Sourcing инфраструктура
- Domain commands и events (из Task 07.1 и 07.2)

Нужно:
1. Добавить поля в Chat aggregate (title, status, priority, assigneeID, dueDate, severity)
2. Расширить ConvertToTask для создания событий
3. Добавить методы для всех Entity Management операций
4. Реализовать валидацию статусов по типам

## Цели

1. Расширить структуру Chat aggregate новыми полями
2. Обновить метод ConvertToTask для Event Sourcing
3. Добавить новые методы (ConvertToBug, ConvertToEpic)
4. Реализовать методы Entity Management
5. Добавить валидацию статусов
6. Обновить Apply() для новых событий

## Технические требования

### 1. Расширение структуры Chat

```go
// В файле internal/domain/chat/chat.go

type Chat struct {
	id           uuid.UUID
	workspaceID  uuid.UUID
	chatType     Type
	isPublic     bool
	createdBy    uuid.UUID
	createdAt    time.Time
	participants []Participant

	// Поля для typed чатов (Task/Bug/Epic)
	title      string
	status     string
	priority   string
	assigneeID *uuid.UUID
	dueDate    *time.Time
	severity   string // только для Bug

	// Event sourcing
	version           int
	uncommittedEvents []event.DomainEvent
}
```

### 2. Обновление ConvertToTask

Заменить существующий метод:

```go
// ConvertToTask конвертирует Discussion в Task
func (c *Chat) ConvertToTask(title string, userID uuid.UUID) error {
	// Валидация
	if c.chatType != TypeDiscussion {
		return errs.ErrInvalidState
	}
	if title == "" {
		return errs.ErrInvalidInput
	}
	if userID.IsZero() {
		return errs.ErrInvalidInput
	}

	// Создание события
	evt := NewTypeChanged(
		c.id,
		c.chatType,
		TypeTask,
		title,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	// Применение и сохранение события
	c.applyEvent(evt)
	return nil
}
```

### 3. Добавление ConvertToBug и ConvertToEpic

```go
// ConvertToBug конвертирует Discussion в Bug
func (c *Chat) ConvertToBug(title string, userID uuid.UUID) error {
	if c.chatType != TypeDiscussion {
		return errs.ErrInvalidState
	}
	if title == "" {
		return errs.ErrInvalidInput
	}
	if userID.IsZero() {
		return errs.ErrInvalidInput
	}

	evt := NewTypeChanged(
		c.id,
		c.chatType,
		TypeBug,
		title,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	c.applyEvent(evt)
	return nil
}

// ConvertToEpic конвертирует Discussion в Epic
func (c *Chat) ConvertToEpic(title string, userID uuid.UUID) error {
	if c.chatType != TypeDiscussion {
		return errs.ErrInvalidState
	}
	if title == "" {
		return errs.ErrInvalidInput
	}
	if userID.IsZero() {
		return errs.ErrInvalidInput
	}

	evt := NewTypeChanged(
		c.id,
		c.chatType,
		TypeEpic,
		title,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	c.applyEvent(evt)
	return nil
}
```

### 4. Entity Management методы

```go
// ChangeStatus изменяет статус typed чата
func (c *Chat) ChangeStatus(newStatus string, userID uuid.UUID) error {
	// Валидация: только для typed чатов
	if c.chatType == TypeDiscussion {
		return errs.ErrInvalidState
	}

	// Валидация статуса
	if err := c.validateStatus(newStatus); err != nil {
		return err
	}

	// Если статус не изменился
	if c.status == newStatus {
		return nil
	}

	oldStatus := c.status

	evt := NewStatusChanged(
		c.id,
		oldStatus,
		newStatus,
		userID,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	c.applyEvent(evt)
	return nil
}

// AssignUser назначает исполнителя
func (c *Chat) AssignUser(assigneeID *uuid.UUID, userID uuid.UUID) error {
	if c.chatType == TypeDiscussion {
		return errs.ErrInvalidState
	}

	// Снятие assignee
	if assigneeID == nil {
		if c.assigneeID == nil {
			return nil // Уже нет assignee
		}

		evt := NewAssigneeRemoved(
			c.id,
			*c.assigneeID,
			userID,
			c.version+1,
			event.Metadata{
				CorrelationID: uuid.NewUUID().String(),
				CausationID:   uuid.NewUUID().String(),
				UserID:        userID.String(),
			},
		)
		c.applyEvent(evt)
		return nil
	}

	// Проверка: не назначаем того же пользователя
	if c.assigneeID != nil && *c.assigneeID == *assigneeID {
		return nil
	}

	// Назначение assignee
	evt := NewUserAssigned(
		c.id,
		*assigneeID,
		userID,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)
	c.applyEvent(evt)
	return nil
}

// SetPriority устанавливает приоритет
func (c *Chat) SetPriority(priority string, userID uuid.UUID) error {
	if c.chatType == TypeDiscussion {
		return errs.ErrInvalidState
	}

	if err := c.validatePriority(priority); err != nil {
		return err
	}

	if c.priority == priority {
		return nil
	}

	oldPriority := c.priority

	evt := NewPrioritySet(
		c.id,
		oldPriority,
		priority,
		userID,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	c.applyEvent(evt)
	return nil
}

// SetDueDate устанавливает или снимает дедлайн
func (c *Chat) SetDueDate(dueDate *time.Time, userID uuid.UUID) error {
	if c.chatType == TypeDiscussion {
		return errs.ErrInvalidState
	}

	// Снятие due date
	if dueDate == nil {
		if c.dueDate == nil {
			return nil
		}

		evt := NewDueDateRemoved(
			c.id,
			*c.dueDate,
			userID,
			c.version+1,
			event.Metadata{
				CorrelationID: uuid.NewUUID().String(),
				CausationID:   uuid.NewUUID().String(),
				UserID:        userID.String(),
			},
		)
		c.applyEvent(evt)
		return nil
	}

	// Проверка: не устанавливаем ту же дату
	if c.dueDate != nil && c.dueDate.Equal(*dueDate) {
		return nil
	}

	// Установка due date
	evt := NewDueDateSet(
		c.id,
		c.dueDate,
		*dueDate,
		userID,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)
	c.applyEvent(evt)
	return nil
}

// Rename изменяет название чата
func (c *Chat) Rename(newTitle string, userID uuid.UUID) error {
	if c.chatType == TypeDiscussion {
		return errs.ErrInvalidState
	}

	if newTitle == "" {
		return errs.ErrInvalidInput
	}

	if c.title == newTitle {
		return nil
	}

	oldTitle := c.title

	evt := NewChatRenamed(
		c.id,
		oldTitle,
		newTitle,
		userID,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	c.applyEvent(evt)
	return nil
}

// SetSeverity устанавливает severity для Bug
func (c *Chat) SetSeverity(severity string, userID uuid.UUID) error {
	if c.chatType != TypeBug {
		return errs.ErrInvalidState
	}

	if err := c.validateSeverity(severity); err != nil {
		return err
	}

	if c.severity == severity {
		return nil
	}

	oldSeverity := c.severity

	evt := NewSeveritySet(
		c.id,
		oldSeverity,
		severity,
		userID,
		c.version+1,
		event.Metadata{
			CorrelationID: uuid.NewUUID().String(),
			CausationID:   uuid.NewUUID().String(),
			UserID:        userID.String(),
		},
	)

	c.applyEvent(evt)
	return nil
}
```

### 5. Валидация

```go
// validateStatus проверяет валидность статуса для текущего типа чата
func (c *Chat) validateStatus(status string) error {
	var validStatuses []string

	switch c.chatType {
	case TypeTask:
		validStatuses = []string{"To Do", "In Progress", "Done"}
	case TypeBug:
		validStatuses = []string{"New", "Investigating", "Fixed", "Verified"}
	case TypeEpic:
		validStatuses = []string{"Planned", "In Progress", "Completed"}
	default:
		return errs.ErrInvalidState
	}

	for _, valid := range validStatuses {
		if status == valid {
			return nil
		}
	}

	return fmt.Errorf("invalid status '%s' for %s. Available: %s",
		status, c.chatType, strings.Join(validStatuses, ", "))
}

// validatePriority проверяет валидность приоритета
func (c *Chat) validatePriority(priority string) error {
	validPriorities := []string{"Low", "Medium", "High", "Critical"}

	for _, valid := range validPriorities {
		if priority == valid {
			return nil
		}
	}

	return fmt.Errorf("invalid priority '%s'. Available: %s",
		priority, strings.Join(validPriorities, ", "))
}

// validateSeverity проверяет валидность severity для Bug
func (c *Chat) validateSeverity(severity string) error {
	validSeverities := []string{"Minor", "Major", "Critical", "Blocker"}

	for _, valid := range validSeverities {
		if severity == valid {
			return nil
		}
	}

	return fmt.Errorf("invalid severity '%s'. Available: %s",
		severity, strings.Join(validSeverities, ", "))
}
```

### 6. Обновление Apply()

Обновить существующий метод Apply() для обработки новых событий:

```go
// Apply применяет событие для восстановления состояния
func (c *Chat) Apply(e event.DomainEvent) error {
	switch evt := e.(type) {
	case *Created:
		c.id = uuid.UUID(evt.AggregateID())
		c.workspaceID = evt.WorkspaceID
		c.chatType = evt.Type
		c.isPublic = evt.IsPublic
		c.createdBy = evt.CreatedBy
		c.createdAt = evt.CreatedAt
		c.version = evt.Version()

	case *ParticipantAdded:
		c.addParticipantInternal(evt.UserID, evt.Role)
		c.version = evt.Version()

	case *TypeChanged:
		c.chatType = evt.NewType
		c.title = evt.Title
		// Устанавливаем дефолтный статус
		c.status = c.getDefaultStatus()
		c.version = evt.Version()

	case *StatusChanged:
		c.status = evt.NewStatus
		c.version = evt.Version()

	case *UserAssigned:
		assigneeID := evt.AssigneeID
		c.assigneeID = &assigneeID
		c.version = evt.Version()

	case *AssigneeRemoved:
		c.assigneeID = nil
		c.version = evt.Version()

	case *PrioritySet:
		c.priority = evt.NewPriority
		c.version = evt.Version()

	case *DueDateSet:
		dueDate := evt.NewDueDate
		c.dueDate = &dueDate
		c.version = evt.Version()

	case *DueDateRemoved:
		c.dueDate = nil
		c.version = evt.Version()

	case *ChatRenamed:
		c.title = evt.NewTitle
		c.version = evt.Version()

	case *SeveritySet:
		c.severity = evt.NewSeverity
		c.version = evt.Version()

	default:
		// Неизвестные события игнорируем (forward compatibility)
		return nil
	}
	return nil
}

// getDefaultStatus возвращает дефолтный статус для типа чата
func (c *Chat) getDefaultStatus() string {
	switch c.chatType {
	case TypeTask:
		return "To Do"
	case TypeBug:
		return "New"
	case TypeEpic:
		return "Planned"
	default:
		return ""
	}
}

// applyEvent применяет событие и добавляет в uncommitted
func (c *Chat) applyEvent(evt event.DomainEvent) {
	_ = c.Apply(evt)
	c.uncommittedEvents = append(c.uncommittedEvents, evt)
}
```

### 7. Дополнительные Getters

```go
// Title возвращает название typed чата
func (c *Chat) Title() string { return c.title }

// Status возвращает статус typed чата
func (c *Chat) Status() string { return c.status }

// Priority возвращает приоритет
func (c *Chat) Priority() string { return c.priority }

// AssigneeID возвращает ID назначенного пользователя
func (c *Chat) AssigneeID() *uuid.UUID { return c.assigneeID }

// DueDate возвращает дедлайн
func (c *Chat) DueDate() *time.Time { return c.dueDate }

// Severity возвращает severity (для Bug)
func (c *Chat) Severity() string { return c.severity }
```

## Acceptance Criteria

- [ ] Структура Chat расширена новыми полями (title, status, priority, assigneeID, dueDate, severity)
- [ ] Метод ConvertToTask обновлен для Event Sourcing
- [ ] Реализованы методы ConvertToBug и ConvertToEpic
- [ ] Реализованы все Entity Management методы:
  - [ ] ChangeStatus
  - [ ] AssignUser
  - [ ] SetPriority
  - [ ] SetDueDate
  - [ ] Rename
  - [ ] SetSeverity
- [ ] Реализованы validation методы для статусов, приоритетов, severity
- [ ] Обновлен метод Apply() для всех новых событий
- [ ] Добавлены getters для новых полей
- [ ] Код компилируется без ошибок
- [ ] Все методы проверяют, что чат typed (не Discussion)
- [ ] Все методы создают и применяют события

## Примеры использования

```go
// Пример 1: Превращение Discussion в Task
chat := loadChatFromRepo(chatID)
err := chat.ConvertToTask("Implement feature X", userID)
// Chat становится TypeTask с title="Implement feature X", status="To Do"

// Пример 2: Изменение статуса
err := chat.ChangeStatus("In Progress", userID)
// Генерируется StatusChanged event

// Пример 3: Назначение пользователя
err := chat.AssignUser(&alexID, userID)
// Генерируется UserAssigned event

// Пример 4: Снятие assignee
err := chat.AssignUser(nil, userID)
// Генерируется AssigneeRemoved event
```

## Ссылки

- Предыдущая задача: [07.2 - Chat Domain Events](./07.2-chat-domain-events.md)
- Следующая задача: [07.4 - CommandExecutor](./07.4-command-executor.md)
- Существующий код: `internal/domain/chat/chat.go`
