# Task 07.4: CommandExecutor Implementation

**Статус:** ✅ Completed
**Приоритет:** High
**Зависимости:** Task 07.3
**Оценка:** 1 день

## Описание

Реализовать CommandExecutor - компонент, который выполняет tag commands на Chat aggregate. Executor загружает aggregate из репозитория, выполняет команду, публикует события и сохраняет изменения.

## Контекст

В проекте уже есть:
- Tag commands (`internal/domain/tag/commands.go`) - создаются TagProcessor'ом
- Chat domain commands (`internal/domain/chat/commands.go`) - из Task 07.1
- Chat aggregate с методами (`internal/domain/chat/chat.go`) - из Task 07.3
- Repository interfaces

Нужно создать Executor, который:
1. Принимает tag команды
2. Загружает Chat aggregate
3. Преобразует tag команды в вызовы методов aggregate
4. Резолвит пользователей (@alex → UUID)
5. Публикует события
6. Сохраняет aggregate

## Цели

1. Создать файл `internal/domain/tag/executor.go`
2. Реализовать CommandExecutor со всеми execute-методами
3. Добавить резолвинг пользователей для AssignUserCommand
4. Интегрировать с event bus для публикации событий

## Технические требования

### Файл: `internal/domain/tag/executor.go`

```go
package tag

import (
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/lllypuk/flowra/internal/domain/chat"
	"github.com/lllypuk/flowra/internal/domain/event"
	"github.com/lllypuk/flowra/internal/domain/user"
	chatUUID "github.com/lllypuk/flowra/internal/domain/uuid"
)

// CommandExecutor выполняет tag команды на Chat aggregate
type CommandExecutor struct {
	chatRepo chat.Repository
	userRepo user.Repository
	eventBus event.EventBus
}

// NewCommandExecutor создает новый CommandExecutor
func NewCommandExecutor(
	chatRepo chat.Repository,
	userRepo user.Repository,
	eventBus event.EventBus,
) *CommandExecutor {
	return &CommandExecutor{
		chatRepo: chatRepo,
		userRepo: userRepo,
		eventBus: eventBus,
	}
}

// Execute выполняет команду
func (e *CommandExecutor) Execute(cmd Command, actorID uuid.UUID) error {
	switch c := cmd.(type) {
	case CreateTaskCommand:
		return e.executeCreateTask(c, actorID)
	case CreateBugCommand:
		return e.executeCreateBug(c, actorID)
	case CreateEpicCommand:
		return e.executeCreateEpic(c, actorID)
	case ChangeStatusCommand:
		return e.executeChangeStatus(c, actorID)
	case AssignUserCommand:
		return e.executeAssignUser(c, actorID)
	case ChangePriorityCommand:
		return e.executeChangePriority(c, actorID)
	case SetDueDateCommand:
		return e.executeSetDueDate(c, actorID)
	case ChangeTitleCommand:
		return e.executeChangeTitle(c, actorID)
	case SetSeverityCommand:
		return e.executeSetSeverity(c, actorID)
	default:
		return fmt.Errorf("unknown command type: %T", cmd)
	}
}

// executeCreateTask выполняет команду создания Task
func (e *CommandExecutor) executeCreateTask(cmd CreateTaskCommand, actorID uuid.UUID) error {
	// Загрузка чата
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	// Выполнение команды на aggregate
	if err := c.ConvertToTask(cmd.Title, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to convert to task: %w", err)
	}

	// Публикация событий и сохранение
	return e.publishAndSave(c)
}

// executeCreateBug выполняет команду создания Bug
func (e *CommandExecutor) executeCreateBug(cmd CreateBugCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.ConvertToBug(cmd.Title, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to convert to bug: %w", err)
	}

	return e.publishAndSave(c)
}

// executeCreateEpic выполняет команду создания Epic
func (e *CommandExecutor) executeCreateEpic(cmd CreateEpicCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.ConvertToEpic(cmd.Title, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to convert to epic: %w", err)
	}

	return e.publishAndSave(c)
}

// executeChangeStatus выполняет команду изменения статуса
func (e *CommandExecutor) executeChangeStatus(cmd ChangeStatusCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.ChangeStatus(cmd.Status, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to change status: %w", err)
	}

	return e.publishAndSave(c)
}

// executeAssignUser выполняет команду назначения пользователя
func (e *CommandExecutor) executeAssignUser(cmd AssignUserCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	// Резолвинг пользователя
	var assigneeID *chatUUID.UUID
	if cmd.Username != "" && cmd.Username != "@none" {
		username := strings.TrimPrefix(cmd.Username, "@")
		u, err := e.userRepo.FindByUsername(username)
		if err != nil {
			return fmt.Errorf("user %s not found: %w", cmd.Username, err)
		}
		uid := u.ID()
		assigneeID = &uid
	}

	// Выполнение команды
	if err := c.AssignUser(assigneeID, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to assign user: %w", err)
	}

	return e.publishAndSave(c)
}

// executeChangePriority выполняет команду изменения приоритета
func (e *CommandExecutor) executeChangePriority(cmd ChangePriorityCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.SetPriority(cmd.Priority, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to set priority: %w", err)
	}

	return e.publishAndSave(c)
}

// executeSetDueDate выполняет команду установки дедлайна
func (e *CommandExecutor) executeSetDueDate(cmd SetDueDateCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.SetDueDate(cmd.DueDate, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to set due date: %w", err)
	}

	return e.publishAndSave(c)
}

// executeChangeTitle выполняет команду изменения названия
func (e *CommandExecutor) executeChangeTitle(cmd ChangeTitleCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.Rename(cmd.Title, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to rename: %w", err)
	}

	return e.publishAndSave(c)
}

// executeSetSeverity выполняет команду установки severity
func (e *CommandExecutor) executeSetSeverity(cmd SetSeverityCommand, actorID uuid.UUID) error {
	c, err := e.chatRepo.FindByID(chatUUID.UUID(cmd.ChatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	if err := c.SetSeverity(cmd.Severity, chatUUID.UUID(actorID)); err != nil {
		return fmt.Errorf("failed to set severity: %w", err)
	}

	return e.publishAndSave(c)
}

// publishAndSave публикует события и сохраняет aggregate
func (e *CommandExecutor) publishAndSave(c *chat.Chat) error {
	// Получение несохраненных событий
	events := c.GetUncommittedEvents()

	// Публикация событий
	for _, evt := range events {
		if err := e.eventBus.Publish(evt); err != nil {
			return fmt.Errorf("failed to publish event: %w", err)
		}
	}

	// Сохранение aggregate
	if err := e.chatRepo.Save(c); err != nil {
		return fmt.Errorf("failed to save chat: %w", err)
	}

	// Пометка событий как зафиксированных
	c.MarkEventsAsCommitted()

	return nil
}
```

## Acceptance Criteria

- [ ] Создан файл `internal/domain/tag/executor.go`
- [ ] Реализован CommandExecutor с зависимостями (chatRepo, userRepo, eventBus)
- [ ] Реализован метод Execute() с type switch для всех команд
- [ ] Реализованы все execute-методы:
  - [ ] executeCreateTask
  - [ ] executeCreateBug
  - [ ] executeCreateEpic
  - [ ] executeChangeStatus
  - [ ] executeAssignUser (с резолвингом пользователей)
  - [ ] executeChangePriority
  - [ ] executeSetDueDate
  - [ ] executeChangeTitle
  - [ ] executeSetSeverity
- [ ] Реализован метод publishAndSave для публикации событий
- [ ] Все ошибки правильно обрабатываются и оборачиваются
- [ ] Код компилируется без ошибок

## Дизайн решения

### Паттерн Command Handler

```
TagProcessor → Tag Command → CommandExecutor → Chat Aggregate → Domain Events → Event Bus
                                    ↓
                            User Resolution
                            (для @mentions)
```

### Обработка ошибок

1. **Repository errors**: Оборачиваем с контекстом
2. **Domain errors**: Пропускаем как есть (из aggregate)
3. **User not found**: Специальное сообщение с username
4. **Event publishing errors**: Критичные, останавливают выполнение

### Резолвинг пользователей

Только для `AssignUserCommand`:
- `@alex` → FindByUsername("alex") → UUID
- `@none` или nil → nil (снятие assignee)
- Username не найден → ошибка

### Event Sourcing

1. Aggregate создает события
2. Executor публикует через Event Bus
3. Aggregate сохраняется в repository
4. События помечаются как committed

## Примеры использования

```go
// Пример 1: Создание Task
executor := NewCommandExecutor(chatRepo, userRepo, eventBus)

cmd := CreateTaskCommand{
    ChatID: chatID,
    Title:  "Implement feature X",
}

err := executor.Execute(cmd, actorID)
// События публикуются, aggregate сохраняется

// Пример 2: Назначение пользователя
cmd := AssignUserCommand{
    ChatID:   chatID,
    Username: "@alex",
}

err := executor.Execute(cmd, actorID)
// 1. Резолвит @alex в UUID
// 2. Вызывает c.AssignUser(alexID, actorID)
// 3. Публикует UserAssigned event
// 4. Сохраняет aggregate
```

## Тесты

Будут реализованы в Task 07.6. Основные сценарии:
- Успешное выполнение каждой команды
- Ошибки repository
- Ошибки domain validation
- User not found
- Event publishing failures

## Потенциальные проблемы

### 1. Транзакционность

**Проблема**: Что если event опубликовался, а Save провалился?

**Решение (временное)**: В текущей реализации событие будет потеряно. В production нужен:
- Unit of Work паттерн
- Или Outbox паттерн
- Или Transactional Event Bus

**Для текущей задачи**: Принимаем риск, отмечаем в TODO

### 2. Optimistic Locking

**Проблема**: Конкурентные изменения aggregate

**Решение (будущее)**: Использовать version из aggregate для optimistic locking в repository

**Для текущей задачи**: Не реализуем, отмечаем в TODO

## TODO для будущих улучшений

```go
// TODO: Add Unit of Work pattern for transactional consistency
// TODO: Add optimistic locking using aggregate version
// TODO: Add retry logic for transient failures
// TODO: Add distributed tracing correlation IDs
// TODO: Add metrics for command execution time
```

## Ссылки

- Предыдущая задача: [07.3 - Chat Aggregate Methods](./07.3-chat-aggregate-methods.md)
- Следующая задача: [07.5 - Integration Handler](./07.5-integration-handler.md)
- Tag Commands: `internal/domain/tag/commands.go`
- Chat Aggregate: `internal/domain/chat/chat.go`
