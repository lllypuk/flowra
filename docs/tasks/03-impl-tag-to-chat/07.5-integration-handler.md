# Task 07.5: Integration Handler

**Статус:** ✅ Completed
**Приоритет:** High
**Зависимости:** Task 07.4
**Оценка:** 0.5 дня

## Описание

Создать TagHandler - компонент, который объединяет весь pipeline обработки сообщений с тегами: парсинг → валидация → обработка → выполнение → bot response.

## Контекст

В проекте уже есть:
- `TagProcessor` - обрабатывает теги и генерирует tag commands
- `CommandExecutor` - выполняет tag commands на Chat aggregate
- `Formatter` - форматирует bot responses

Нужно создать Handler, который:
1. Принимает сообщение от пользователя
2. Парсит теги через Processor
3. Выполняет команды через Executor
4. Генерирует bot response через Formatter
5. Обрабатывает ошибки

## Цели

1. Создать файл `internal/domain/tag/handler.go`
2. Реализовать TagHandler с полным pipeline
3. Интегрировать все компоненты
4. Добавить обработку ошибок и генерацию responses

## Технические требования

### Файл: `internal/domain/tag/handler.go`

```go
package tag

import (
	"fmt"

	"github.com/google/uuid"
	"github.com/flowra/flowra/internal/domain/chat"
	"github.com/flowra/flowra/internal/domain/message"
	chatUUID "github.com/flowra/flowra/internal/domain/uuid"
)

// TagHandler обрабатывает сообщения с тегами
type TagHandler struct {
	processor   *Processor
	executor    *CommandExecutor
	formatter   *Formatter
	messageRepo message.Repository
	chatRepo    chat.Repository
}

// NewTagHandler создает новый TagHandler
func NewTagHandler(
	processor *Processor,
	executor *CommandExecutor,
	formatter *Formatter,
	messageRepo message.Repository,
	chatRepo chat.Repository,
) *TagHandler {
	return &TagHandler{
		processor:   processor,
		executor:    executor,
		formatter:   formatter,
		messageRepo: messageRepo,
		chatRepo:    chatRepo,
	}
}

// HandleMessageWithTags обрабатывает сообщение с тегами
func (h *TagHandler) HandleMessageWithTags(
	chatID uuid.UUID,
	authorID uuid.UUID,
	content string,
) error {
	// 1. Получение контекста чата
	c, err := h.chatRepo.FindByID(chatUUID.UUID(chatID))
	if err != nil {
		return fmt.Errorf("failed to load chat: %w", err)
	}

	// Определяем текущий тип entity для валидации
	currentEntityType := h.getEntityType(c)

	// 2. Обработка тегов через Processor
	result := h.processor.ProcessMessage(chatID, content, currentEntityType)

	// 3. Сохранение сообщения
	msg := message.NewMessage(
		chatUUID.UUID(chatID),
		chatUUID.UUID(authorID),
		result.PlainText, // текст без тегов
	)
	if err := h.messageRepo.Save(msg); err != nil {
		return fmt.Errorf("failed to save message: %w", err)
	}

	// 4. Выполнение команд
	executionErrors := h.executeCommands(result.AppliedTags, authorID)

	// 5. Генерация bot response
	allErrors := append(result.Errors, executionErrors...)
	if botResponse := h.formatter.FormatBotResponse(result, allErrors); botResponse != "" {
		if err := h.sendBotResponse(chatID, botResponse); err != nil {
			// Логируем, но не фейлим весь процесс
			fmt.Printf("failed to send bot response: %v\n", err)
		}
	}

	return nil
}

// executeCommands выполняет все команды из результата обработки
func (h *TagHandler) executeCommands(applications []TagApplication, actorID uuid.UUID) []TagError {
	var errors []TagError

	for _, app := range applications {
		if app.Command == nil {
			continue
		}

		if err := h.executor.Execute(app.Command, actorID); err != nil {
			errors = append(errors, TagError{
				TagKey:   app.TagKey,
				TagValue: app.TagValue,
				Error:    err,
				Severity: ErrorSeverityError,
			})
		}
	}

	return errors
}

// sendBotResponse отправляет bot response в чат
func (h *TagHandler) sendBotResponse(chatID uuid.UUID, response string) error {
	// Создаем системное сообщение от бота
	botMessage := message.NewMessage(
		chatUUID.UUID(chatID),
		chatUUID.UUID{}, // Zero UUID для системных сообщений
		response,
	)

	if err := h.messageRepo.Save(botMessage); err != nil {
		return fmt.Errorf("failed to save bot message: %w", err)
	}

	return nil
}

// getEntityType возвращает тип entity для валидации
func (h *TagHandler) getEntityType(c *chat.Chat) string {
	switch c.Type() {
	case chat.TypeTask:
		return "Task"
	case chat.TypeBug:
		return "Bug"
	case chat.TypeEpic:
		return "Epic"
	default:
		return ""
	}
}
```

## Acceptance Criteria

- [ ] Создан файл `internal/domain/tag/handler.go`
- [ ] Реализован TagHandler с зависимостями
- [ ] Реализован метод HandleMessageWithTags() с полным pipeline:
  - [ ] Загрузка Chat для получения контекста
  - [ ] Обработка тегов через Processor
  - [ ] Сохранение user message
  - [ ] Выполнение команд через Executor
  - [ ] Генерация bot response через Formatter
  - [ ] Отправка bot response
- [ ] Реализован метод executeCommands()
- [ ] Реализован метод sendBotResponse()
- [ ] Реализован helper getEntityType()
- [ ] Ошибки правильно собираются и передаются в Formatter
- [ ] Код компилируется без ошибок

## Дизайн решения

### Pipeline обработки

```
User Message
    ↓
1. Load Chat (для контекста)
    ↓
2. TagProcessor.ProcessMessage()
    ├─ Parse tags
    ├─ Validate tags
    └─ Generate tag commands
    ↓
3. Save user message
    ↓
4. CommandExecutor.Execute() для каждой команды
    ├─ Load aggregate
    ├─ Execute domain method
    ├─ Publish events
    └─ Save aggregate
    ↓
5. Formatter.FormatBotResponse()
    ├─ Success messages
    └─ Error messages
    ↓
6. Send bot response
```

### Обработка ошибок

1. **Validation errors** (из Processor):
   - Собираются в `result.Errors`
   - Передаются в Formatter
   - Не останавливают обработку других тегов

2. **Execution errors** (из Executor):
   - Собираются в `executionErrors`
   - Объединяются с validation errors
   - Передаются в Formatter

3. **Critical errors**:
   - Failed to load chat → return error
   - Failed to save message → return error
   - Failed to send bot response → log warning (не фейлим)

### Entity Type для валидации

Processor нужно знать текущий тип entity для валидации статусов:
- Task → статусы "To Do", "In Progress", "Done"
- Bug → статусы "New", "Investigating", "Fixed", "Verified"
- Discussion → статусы недопустимы

Handler загружает Chat и передает тип в Processor.

## Примеры использования

```go
// Инициализация
processor := NewProcessor()
executor := NewCommandExecutor(chatRepo, userRepo, eventBus)
formatter := NewFormatter()
handler := NewTagHandler(processor, executor, formatter, messageRepo, chatRepo)

// Обработка сообщения
err := handler.HandleMessageWithTags(
    chatID,
    authorID,
    "#task Implement feature X #priority High #assignee @alex",
)

// Pipeline:
// 1. Загружает chat (Discussion)
// 2. Парсит 3 тега
// 3. Сохраняет "Implement feature X" (без тегов)
// 4. Выполняет:
//    - ConvertToTask("Implement feature X")
//    - SetPriority("High")
//    - AssignUser(@alex)
// 5. Генерирует bot response:
//    "✅ Task created: Implement feature X
//     ✅ Priority set to High
//     ✅ Assigned to @alex"
// 6. Отправляет bot response
```

## Интеграция с остальной системой

### Вызов из WebSocket Handler

```go
// internal/handler/websocket/message_handler.go

func (h *MessageHandler) HandleIncomingMessage(msg IncomingMessage) error {
    // ... валидация, проверка прав доступа ...

    // Проверяем наличие тегов
    if containsTags(msg.Content) {
        return h.tagHandler.HandleMessageWithTags(
            msg.ChatID,
            msg.AuthorID,
            msg.Content,
        )
    }

    // Обычное сообщение без тегов
    return h.saveMessage(msg)
}
```

## Улучшения для будущего

```go
// TODO: Add transaction support for message + commands
// TODO: Add idempotency keys for duplicate message handling
// TODO: Add rate limiting for tag commands
// TODO: Add permission checks (can user execute this command?)
// TODO: Add notification sending after successful commands
// TODO: Add WebSocket broadcasting of bot response
// TODO: Add command queuing for heavy operations
```

## Тесты

Будут реализованы в Task 07.6. Основные сценарии:
- Успешная обработка сообщения с тегами
- Validation errors
- Execution errors
- Mixed success/failure
- Bot response generation
- Message saving

## Альтернативные варианты

### Вариант 1: Handler с транзакциями

```go
func (h *TagHandler) HandleMessageWithTags(...) error {
    tx := h.db.Begin()
    defer tx.Rollback()

    // ... обработка ...

    return tx.Commit()
}
```

**Плюсы**: Атомарность
**Минусы**: Требует database transactions
**Решение**: Отложить на Phase 2

### Вариант 2: Async command execution

```go
func (h *TagHandler) HandleMessageWithTags(...) error {
    // Сохраняем сообщение
    // Публикуем команды в очередь
    // Возвращаем success немедленно
}
```

**Плюсы**: Быстрый ответ пользователю
**Минусы**: Сложнее обработка ошибок
**Решение**: Отложить на Phase 3

## Ссылки

- Предыдущая задача: [07.4 - CommandExecutor](./07.4-command-executor.md)
- Следующая задача: [07.6 - Unit Tests](./07.6-unit-tests.md)
- Processor: `internal/domain/tag/processor.go`
- Formatter: `internal/domain/tag/formatter.go`
