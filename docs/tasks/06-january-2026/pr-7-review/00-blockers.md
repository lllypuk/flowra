# PR Review Blockers — PR #7 `Feature/january plan` (lllypuk/flowra)

**Цель:** зафиксировать блокеры из ревью PR #7 и варианты исправления.  
**Важно:** без оценок времени. Фокус — на том, что мешает безопасному мерджу и как это поправить.

---

## Контекст (кратко)

PR очень большой и включает:
- `cmd/api/*`: entry point, DI container, routes, graceful shutdown, health endpoints
- обновления документации (README/DEPLOYMENT/DEVELOPMENT/ARCHITECTURE/OpenAPI/Postman)
- обновления `Makefile`, `go.mod/go.sum`
- изменения в слоях application (ошибки), handler/http, middleware, infrastructure

---

## Блокер 1 — DI container “протекает” mock-ами (не production-ready wiring)

### Симптомы / что видно в PR
В `cmd/api/container.go` в `setupHTTPHandlers()` создаются mock-реализации:
- `httphandler.NewMockAuthService()`
- `httphandler.NewMockUserRepository()`
- `httphandler.NewMockWorkspaceService()`, `NewMockMemberService()`
- `httphandler.NewMockChatService()`
- `middleware.NewMockWorkspaceAccessChecker()`
и т.п.

В результате `cmd/api` поднимается с моками независимо от окружения. Это делает приложение “демо-скелетом”, а не реальным запускным контуром.

### Почему это блокер
- Entry point становится **непредсказуемым**: разработчик ожидает работу с реальными репозиториями/юзкейсами, но получает заглушки.
- Риск “тихого” поведения в проде/стейдже (если конфиг/окружение не переключает wiring).
- Нарушение принципа: entrypoint должен быть **единственным местом сборки реальных зависимостей** (а моки — только для тестов/локальной песочницы).

### Варианты исправления

**Вариант A (предпочтительный): условное wiring по окружению**
1. Ввести явный режим запуска, например:
   - `cfg.Server.Mode` / `cfg.App.Mode`: `real` | `mock`
   - или использовать уже существующие `cfg.IsDevelopment()` / `cfg.IsProduction()`
2. В `setupHTTPHandlers()`:
   - в `real` — собирать handlers на реальных use case / сервисах / репозиториях
   - в `mock` — разрешать мок-реализации
3. Логировать на старте выбранный режим wiring (важно для диагностики).

**Вариант B: убрать моки полностью из `cmd/api`**
- Все mock-реализации оставить:
  - в `_test.go` файлах
  - или в `tests/testutil`
- `cmd/api` всегда собирает реальные зависимости.
- Для dev-режима использовать реальные зависимости + dev-конфиг/флаги.

**Вариант C: отдельный “demo” entrypoint**
- Оставить моки, но вынести их в отдельный бинарник, например `cmd/api-demo/main.go`.
- `cmd/api/main.go` — только real wiring.

**Acceptance criteria**
- В `cmd/api/main.go` по умолчанию поднимается реальная сборка.
- “Моковый режим” возможен только явно и не может включиться случайно.

---

## Блокер 2 — Readiness/health использует потенциально некорректный request context (`AcquireContext()`)

### Симптомы / что видно в PR
В `cmd/api/routes.go` используется конструкция вида:
- readiness callback вызывает `c.IsReady(...)`, получая контекст через `e.AcquireContext().Request().Context()`.

### Почему это блокер
- `AcquireContext()` не гарантирует, что контекст связан с конкретным запросом, который сейчас обрабатывается.
- Возможны:
  - гонки
  - невалидные/нулевые `Request()`
  - контекст “не того запроса”
- В худшем случае readiness/health будет “флапать” или показывать неверный статус под нагрузкой.

### Варианты исправления

**Вариант A (предпочтительный): readiness handler получает `ctx` из текущего запроса**
- `IsReady` должен вызываться так: `c.IsReady(ctx.Request().Context())` **внутри** handler’а `/ready`.
- Если `router.RegisterHealthEndpoints` принимает callback без аргументов, заменить API на:
  - `func(ctx context.Context) bool` или
  - `func(echo.Context) bool`
  чтобы контекст приходил от обработчика, а не из “глобального Echo”.

**Вариант B: readiness callback использует `context.Background()`**
- Это хуже, чем вариант A (потеря cancellation/deadline), но лучше, чем `AcquireContext()`.

**Acceptance criteria**
- `IsReady()` вызывается только с контекстом текущего запроса или `context.Background()`.
- Нет использования `AcquireContext()` для получения `Request().Context()`.

---

## Блокер 3 — Дублирование и расхождение health/status констант и контрактов

### Симптомы / что видно в PR
- В `cmd/api/container.go` свои `healthStatusHealthy/unhealthy/degraded`.
- В `cmd/api/routes.go` свои `statusHealthy/unhealthy/ready/not ready`.
- Плюс есть одновременно два подхода:
  - `router.RegisterHealthEndpoints(...)`
  - `SetupHealthEndpoints(e, c)` (в том же файле)

### Почему это блокер
- Контракт health endpoints начинает “расползаться”, риск несовместимости:
  - `/ready` может вернуть “ready” в одном месте и “healthy” в другом
  - разные форматы JSON и статусы
- Это особенно опасно для:
  - k8s probes
  - мониторинга
  - интеграционных тестов

### Варианты исправления

**Вариант A (предпочтительный): единый модуль health endpoints**
- Вынести в `internal/infrastructure/httpserver/health` или `internal/handler/http/health`.
- Определить единый формат:
  - `/health` (liveness): всегда 200 + `{status:"healthy"}`
  - `/ready` (readiness): 200/503 + `{status:"ready"/"not_ready", components:[...]}`
  - `/health/details` при необходимости
- Использовать один источник констант и структуры ответа.

**Вариант B: удалить один из двух механизмов**
- Оставить либо `router.RegisterHealthEndpoints`, либо `SetupHealthEndpoints`.
- Второй удалить, чтобы не плодить точки расширения.

**Acceptance criteria**
- Константы статусов определены в одном месте.
- Роутинг health endpoints подключается ровно одним способом.
- Формат ответов стабилен и документирован (README/DEPLOYMENT/DEVELOPMENT).

---

## Блокер 4 — Добавлен загадочный файл `api` в корне репозитория

### Симптомы / что видно в PR
В списке изменённых файлов фигурирует путь `api` (status: added). Это может быть:
- бинарник
- артефакт сборки
- ошибочно добавленный placeholder

### Почему это блокер
- Бинарники/артефакты нельзя хранить в git.
- Если это placeholder — он должен быть явным и понятным, иначе вводит в заблуждение.

### Варианты исправления

**Вариант A: удалить файл `api` из PR**
- Если это артефакт — удалить и добавить правило в `.gitignore` (например `bin/`, `api`, `*.exe` и т.п. по ситуации).

**Вариант B: если это директория/скрипт — переименовать и задокументировать**
- Например `bin/api` (артефакт) — не коммитить.
- Если нужен placeholder — использовать `cmd/api` уже есть, значит в корне `api` не нужен.

**Acceptance criteria**
- В PR нет бинарников/артефактов.
- Структура проекта не содержит неоднозначных “магических” файлов.

---

## Блокер 5 — “Пустые” файлы в diff (added, но без patch): нельзя подтвердить реализацию

### Симптомы / что видно в PR
Часть файлов отображается как добавленная, но содержимое в diff не видно (patch отсутствует). Среди них встречаются:
- `internal/infrastructure/eventbus/*.go`
- `internal/infrastructure/httpserver/*.go`
- `internal/middleware/*.go`
- `tests/e2e/*.go`
- некоторые handler/websocket файлы

### Почему это блокер
- Невозможно проверить корректность реализации.
- Риск, что часть файлов реально пустая (или случайно добавлена).
- README/документация заявляет о готовности E2E/WS/EventBus — но без кода это неподтверждаемо.

### Варианты исправления

**Вариант A: убедиться, что файлы не пустые и diff отображается**
- Пересоздать/перекоммитить изменения так, чтобы GitHub показывал содержимое (иногда помогает “touch”/перекоммит без LFS, но LFS тут маловероятен для `.go`).
- Проверить, что в ветке реально есть код.

**Вариант B: если файлы пустые — удалить их из PR**
- Либо заменить минимальными реализациями с тестами.

**Acceptance criteria**
- Все ключевые компоненты, заявленные в PR description/README, имеют проверяемый код.
- Нет “пустышек” среди `.go` файлов.

---

## Блокер 6 — Автотесты контейнера содержат “псевдотесты” и неверные ожидания

### Симптомы / что видно в PR
`cmd/api/container_test.go` содержит тесты вида:
- “не можем протестировать, просто проверим что cfg not nil”
- тесты, которые ожидают “будет panic или error”, но не проверяют ни panic, ни error
- тесты, которые проверяют тривиальные константы вместо поведения

### Почему это блокер
- Создаёт ложное ощущение покрытия.
- Поддержка таких тестов превращается в шум и снижает доверие к suite.

### Варианты исправления

**Вариант A: переписать тесты на проверку реального поведения**
- Ввести точки расширения/инъекции для Mongo/Redis (фабрики, интерфейсы).
- Тестировать, что `NewContainer`:
  - валидирует конфиг
  - корректно вызывает init steps
  - корректно закрывает partially-initialized ресурсы

**Вариант B: удалить псевдотесты**
- Если пока невозможно протестировать без больших рефакторингов — лучше убрать нерелевантные тесты, оставив реальные.

**Acceptance criteria**
- Тесты проверяют контракт функций (ожидаемый output/error/panic).
- Нет тестов “ради галочки”.

---

## Глобальная рекомендация по снижению риска мерджа

Так как PR очень большой, безопаснее:
1. Выделить **минимальный мердж-юнит**: `cmd/api` + `internal/config` + реальный wiring + health endpoints.
2. Доки/OpenAPI/Postman вынести в отдельный PR (или хотя бы отдельный commit), чтобы упрощать ревью и откат.
3. Любые “готовность 95% / 84 E2E” подтверждать реальными тестовыми прогонами (в CI или локально) и ссылкой на логи.

---