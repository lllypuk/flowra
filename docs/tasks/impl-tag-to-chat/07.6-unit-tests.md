# Task 07.6: Unit Tests

**Статус:** ✅ Completed
**Приоритет:** High
**Зависимости:** Task 07.3, 07.4, 07.5
**Оценка:** 1 день

## Описание

Написать comprehensive unit тесты для всех компонентов, реализованных в Task 07: Chat aggregate методы, CommandExecutor, TagHandler.

## Контекст

Нужно протестировать:
1. **Chat Aggregate** - все новые методы и event sourcing
2. **CommandExecutor** - выполнение всех команд
3. **TagHandler** - полный pipeline обработки

Используем:
- Table-driven tests для множественных сценариев
- Mocks для dependencies (repositories, event bus)
- Test helpers для создания test data

## Цели

1. Расширить `internal/domain/chat/chat_test.go`
2. Создать `internal/domain/tag/executor_test.go`
3. Создать `internal/domain/tag/handler_test.go`
4. Достичь >80% code coverage

## Технические требования

### 1. Chat Aggregate Tests

Расширить файл: `internal/domain/chat/chat_test.go`

```go
package chat_test

import (
	"testing"
	"time"

	"github.com/lllypuk/teams-up/internal/domain/chat"
	"github.com/lllypuk/teams-up/internal/domain/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestChat_ConvertToTask(t *testing.T) {
	tests := []struct {
		name        string
		chatType    chat.Type
		title       string
		wantErr     bool
		wantType    chat.Type
		wantStatus  string
		wantEvents  int
	}{
		{
			name:       "convert discussion to task",
			chatType:   chat.TypeDiscussion,
			title:      "Test Task",
			wantErr:    false,
			wantType:   chat.TypeTask,
			wantStatus: "To Do",
			wantEvents: 1,
		},
		{
			name:     "cannot convert task to task",
			chatType: chat.TypeTask,
			title:    "Test",
			wantErr:  true,
		},
		{
			name:     "empty title",
			chatType: chat.TypeDiscussion,
			title:    "",
			wantErr:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Arrange
			c := createTestChat(t, tt.chatType)
			userID := uuid.NewUUID()

			// Act
			err := c.ConvertToTask(tt.title, userID)

			// Assert
			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.wantType, c.Type())
			assert.Equal(t, tt.title, c.Title())
			assert.Equal(t, tt.wantStatus, c.Status())

			events := c.GetUncommittedEvents()
			assert.Len(t, events, tt.wantEvents)
		})
	}
}

func TestChat_ChangeStatus(t *testing.T) {
	tests := []struct {
		name          string
		chatType      chat.Type
		initialStatus string
		newStatus     string
		wantErr       bool
	}{
		{
			name:          "valid task status change",
			chatType:      chat.TypeTask,
			initialStatus: "To Do",
			newStatus:     "In Progress",
			wantErr:       false,
		},
		{
			name:          "invalid status for task",
			chatType:      chat.TypeTask,
			initialStatus: "To Do",
			newStatus:     "Fixed", // Bug status
			wantErr:       true,
		},
		{
			name:          "cannot set status on discussion",
			chatType:      chat.TypeDiscussion,
			initialStatus: "",
			newStatus:     "To Do",
			wantErr:       true,
		},
		{
			name:          "no change if same status",
			chatType:      chat.TypeTask,
			initialStatus: "To Do",
			newStatus:     "To Do",
			wantErr:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := createTypedChat(t, tt.chatType, "Test")
			userID := uuid.NewUUID()

			err := c.ChangeStatus(tt.newStatus, userID)

			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.newStatus, c.Status())
		})
	}
}

func TestChat_AssignUser(t *testing.T) {
	tests := []struct {
		name       string
		assigneeID *uuid.UUID
		wantNil    bool
		wantEvents int
	}{
		{
			name:       "assign user",
			assigneeID: ptr(uuid.NewUUID()),
			wantNil:    false,
			wantEvents: 1,
		},
		{
			name:       "remove assignee",
			assigneeID: nil,
			wantNil:    true,
			wantEvents: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := createTypedChat(t, chat.TypeTask, "Test")

			// First assign someone
			if tt.name == "remove assignee" {
				initialAssignee := uuid.NewUUID()
				_ = c.AssignUser(&initialAssignee, uuid.NewUUID())
				c.MarkEventsAsCommitted()
			}

			userID := uuid.NewUUID()

			err := c.AssignUser(tt.assigneeID, userID)

			require.NoError(t, err)

			if tt.wantNil {
				assert.Nil(t, c.AssigneeID())
			} else {
				assert.NotNil(t, c.AssigneeID())
				assert.Equal(t, *tt.assigneeID, *c.AssigneeID())
			}

			events := c.GetUncommittedEvents()
			assert.Len(t, events, tt.wantEvents)
		})
	}
}

func TestChat_SetPriority(t *testing.T) {
	validPriorities := []string{"Low", "Medium", "High", "Critical"}

	for _, priority := range validPriorities {
		t.Run("set priority "+priority, func(t *testing.T) {
			c := createTypedChat(t, chat.TypeTask, "Test")
			userID := uuid.NewUUID()

			err := c.SetPriority(priority, userID)

			require.NoError(t, err)
			assert.Equal(t, priority, c.Priority())
		})
	}

	t.Run("invalid priority", func(t *testing.T) {
		c := createTypedChat(t, chat.TypeTask, "Test")
		userID := uuid.NewUUID()

		err := c.SetPriority("InvalidPriority", userID)

		assert.Error(t, err)
	})
}

func TestChat_SetDueDate(t *testing.T) {
	t.Run("set due date", func(t *testing.T) {
		c := createTypedChat(t, chat.TypeTask, "Test")
		userID := uuid.NewUUID()
		dueDate := time.Now().Add(24 * time.Hour)

		err := c.SetDueDate(&dueDate, userID)

		require.NoError(t, err)
		assert.NotNil(t, c.DueDate())
		assert.True(t, c.DueDate().Equal(dueDate))
	})

	t.Run("remove due date", func(t *testing.T) {
		c := createTypedChat(t, chat.TypeTask, "Test")
		userID := uuid.NewUUID()

		// First set a due date
		dueDate := time.Now().Add(24 * time.Hour)
		_ = c.SetDueDate(&dueDate, userID)
		c.MarkEventsAsCommitted()

		// Now remove it
		err := c.SetDueDate(nil, userID)

		require.NoError(t, err)
		assert.Nil(t, c.DueDate())
	})
}

func TestChat_Rename(t *testing.T) {
	t.Run("rename chat", func(t *testing.T) {
		c := createTypedChat(t, chat.TypeTask, "Old Title")
		userID := uuid.NewUUID()

		err := c.Rename("New Title", userID)

		require.NoError(t, err)
		assert.Equal(t, "New Title", c.Title())
	})

	t.Run("empty title", func(t *testing.T) {
		c := createTypedChat(t, chat.TypeTask, "Title")
		userID := uuid.NewUUID()

		err := c.Rename("", userID)

		assert.Error(t, err)
	})
}

func TestChat_SetSeverity(t *testing.T) {
	validSeverities := []string{"Minor", "Major", "Critical", "Blocker"}

	for _, severity := range validSeverities {
		t.Run("set severity "+severity, func(t *testing.T) {
			c := createTypedChat(t, chat.TypeBug, "Test")
			userID := uuid.NewUUID()

			err := c.SetSeverity(severity, userID)

			require.NoError(t, err)
			assert.Equal(t, severity, c.Severity())
		})
	}

	t.Run("cannot set severity on task", func(t *testing.T) {
		c := createTypedChat(t, chat.TypeTask, "Test")
		userID := uuid.NewUUID()

		err := c.SetSeverity("Critical", userID)

		assert.Error(t, err)
	})
}

func TestChat_EventSourcing(t *testing.T) {
	t.Run("replay events", func(t *testing.T) {
		// Create chat and perform operations
		c := createTestChat(t, chat.TypeDiscussion)
		userID := uuid.NewUUID()

		_ = c.ConvertToTask("Test Task", userID)
		_ = c.SetPriority("High", userID)
		assigneeID := uuid.NewUUID()
		_ = c.AssignUser(&assigneeID, userID)

		// Get events
		events := c.GetUncommittedEvents()
		require.Len(t, events, 3)

		// Create new aggregate and replay
		c2 := chat.NewChat(c.WorkspaceID(), chat.TypeDiscussion, true, c.CreatedBy())
		for _, evt := range events {
			_ = c2.Apply(evt)
		}

		// Verify state is same
		assert.Equal(t, c.Type(), c2.Type())
		assert.Equal(t, c.Title(), c2.Title())
		assert.Equal(t, c.Priority(), c2.Priority())
		assert.Equal(t, c.AssigneeID(), c2.AssigneeID())
	})
}

// Test helpers

func createTestChat(t *testing.T, chatType chat.Type) *chat.Chat {
	t.Helper()
	c, err := chat.NewChat(
		uuid.NewUUID(),
		chatType,
		true,
		uuid.NewUUID(),
	)
	require.NoError(t, err)
	c.MarkEventsAsCommitted() // Clear creation events
	return c
}

func createTypedChat(t *testing.T, chatType chat.Type, title string) *chat.Chat {
	t.Helper()
	c := createTestChat(t, chat.TypeDiscussion)
	userID := uuid.NewUUID()

	switch chatType {
	case chat.TypeTask:
		_ = c.ConvertToTask(title, userID)
	case chat.TypeBug:
		_ = c.ConvertToBug(title, userID)
	case chat.TypeEpic:
		_ = c.ConvertToEpic(title, userID)
	}

	c.MarkEventsAsCommitted()
	return c
}

func ptr[T any](v T) *T {
	return &v
}
```

### 2. CommandExecutor Tests

Создать файл: `internal/domain/tag/executor_test.go`

```go
package tag_test

import (
	"errors"
	"testing"

	"github.com/google/uuid"
	"github.com/lllypuk/teams-up/internal/domain/tag"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestCommandExecutor_ExecuteCreateTask(t *testing.T) {
	t.Run("success", func(t *testing.T) {
		// Arrange
		chatRepo := &MockChatRepository{}
		userRepo := &MockUserRepository{}
		eventBus := &MockEventBus{}

		c := createMockChat(chat.TypeDiscussion)
		chatRepo.On("FindByID", mock.Anything).Return(c, nil)
		chatRepo.On("Save", c).Return(nil)
		eventBus.On("Publish", mock.Anything).Return(nil)

		executor := tag.NewCommandExecutor(chatRepo, userRepo, eventBus)

		cmd := tag.CreateTaskCommand{
			ChatID: uuid.New(),
			Title:  "Test Task",
		}

		// Act
		err := executor.Execute(cmd, uuid.New())

		// Assert
		require.NoError(t, err)
		chatRepo.AssertExpectations(t)
		eventBus.AssertExpectations(t)
	})

	t.Run("chat not found", func(t *testing.T) {
		chatRepo := &MockChatRepository{}
		chatRepo.On("FindByID", mock.Anything).Return(nil, errors.New("not found"))

		executor := tag.NewCommandExecutor(chatRepo, nil, nil)
		cmd := tag.CreateTaskCommand{ChatID: uuid.New(), Title: "Test"}

		err := executor.Execute(cmd, uuid.New())

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "not found")
	})
}

func TestCommandExecutor_ExecuteAssignUser(t *testing.T) {
	t.Run("assign user by username", func(t *testing.T) {
		// Arrange
		chatRepo := &MockChatRepository{}
		userRepo := &MockUserRepository{}
		eventBus := &MockEventBus{}

		c := createMockChat(chat.TypeTask)
		alexID := uuid.New()
		alex := createMockUser("alex", alexID)

		chatRepo.On("FindByID", mock.Anything).Return(c, nil)
		userRepo.On("FindByUsername", "alex").Return(alex, nil)
		chatRepo.On("Save", c).Return(nil)
		eventBus.On("Publish", mock.Anything).Return(nil)

		executor := tag.NewCommandExecutor(chatRepo, userRepo, eventBus)

		cmd := tag.AssignUserCommand{
			ChatID:   uuid.New(),
			Username: "@alex",
		}

		// Act
		err := executor.Execute(cmd, uuid.New())

		// Assert
		require.NoError(t, err)
		userRepo.AssertCalled(t, "FindByUsername", "alex")
	})

	t.Run("user not found", func(t *testing.T) {
		chatRepo := &MockChatRepository{}
		userRepo := &MockUserRepository{}

		c := createMockChat(chat.TypeTask)
		chatRepo.On("FindByID", mock.Anything).Return(c, nil)
		userRepo.On("FindByUsername", "nonexistent").Return(nil, errors.New("not found"))

		executor := tag.NewCommandExecutor(chatRepo, userRepo, nil)

		cmd := tag.AssignUserCommand{
			ChatID:   uuid.New(),
			Username: "@nonexistent",
		}

		err := executor.Execute(cmd, uuid.New())

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "not found")
	})

	t.Run("remove assignee", func(t *testing.T) {
		chatRepo := &MockChatRepository{}
		eventBus := &MockEventBus{}

		c := createMockChat(chat.TypeTask)
		chatRepo.On("FindByID", mock.Anything).Return(c, nil)
		chatRepo.On("Save", c).Return(nil)
		eventBus.On("Publish", mock.Anything).Return(nil)

		executor := tag.NewCommandExecutor(chatRepo, nil, eventBus)

		cmd := tag.AssignUserCommand{
			ChatID:   uuid.New(),
			Username: "@none",
		}

		err := executor.Execute(cmd, uuid.New())

		require.NoError(t, err)
	})
}

// Add tests for all other commands:
// - TestCommandExecutor_ExecuteCreateBug
// - TestCommandExecutor_ExecuteCreateEpic
// - TestCommandExecutor_ExecuteChangeStatus
// - TestCommandExecutor_ExecuteChangePriority
// - TestCommandExecutor_ExecuteSetDueDate
// - TestCommandExecutor_ExecuteChangeTitle
// - TestCommandExecutor_ExecuteSetSeverity

// Mock implementations

type MockChatRepository struct {
	mock.Mock
}

func (m *MockChatRepository) FindByID(id uuid.UUID) (*chat.Chat, error) {
	args := m.Called(id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*chat.Chat), args.Error(1)
}

func (m *MockChatRepository) Save(c *chat.Chat) error {
	args := m.Called(c)
	return args.Error(0)
}

// ... other mock types
```

### 3. TagHandler Tests

Создать файл: `internal/domain/tag/handler_test.go`

```go
package tag_test

import (
	"testing"

	"github.com/google/uuid"
	"github.com/lllypuk/teams-up/internal/domain/tag"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestTagHandler_HandleMessageWithTags(t *testing.T) {
	t.Run("success with single tag", func(t *testing.T) {
		// Arrange
		processor := tag.NewProcessor()
		executor := &MockCommandExecutor{}
		formatter := tag.NewFormatter()
		messageRepo := &MockMessageRepository{}
		chatRepo := &MockChatRepository{}

		c := createMockChat(chat.TypeDiscussion)
		chatRepo.On("FindByID", mock.Anything).Return(c, nil)
		messageRepo.On("Save", mock.Anything).Return(nil).Times(2) // user msg + bot msg
		executor.On("Execute", mock.Anything, mock.Anything).Return(nil)

		handler := tag.NewTagHandler(processor, executor, formatter, messageRepo, chatRepo)

		// Act
		err := handler.HandleMessageWithTags(
			uuid.New(),
			uuid.New(),
			"#task Implement feature X",
		)

		// Assert
		require.NoError(t, err)
		executor.AssertCalled(t, "Execute", mock.Anything, mock.Anything)
		messageRepo.AssertNumberOfCalls(t, "Save", 2)
	})

	t.Run("multiple tags", func(t *testing.T) {
		// Test handling message with multiple tags
		// Verify all commands are executed
	})

	t.Run("validation errors", func(t *testing.T) {
		// Test handling of invalid tags
		// Verify error messages in bot response
	})

	t.Run("execution errors", func(t *testing.T) {
		// Test handling of execution failures
		// Verify error messages in bot response
	})
}

// ... more tests
```

## Acceptance Criteria

- [ ] Расширен `internal/domain/chat/chat_test.go`:
  - [ ] Тесты для ConvertToTask/Bug/Epic
  - [ ] Тесты для ChangeStatus (валидация по типам)
  - [ ] Тесты для AssignUser
  - [ ] Тесты для SetPriority
  - [ ] Тесты для SetDueDate
  - [ ] Тесты для Rename
  - [ ] Тесты для SetSeverity
  - [ ] Тесты для Event Sourcing (Apply, replay events)
- [ ] Создан `internal/domain/tag/executor_test.go`:
  - [ ] Тесты для всех execute-методов
  - [ ] Тесты для user resolution
  - [ ] Тесты для error handling
  - [ ] Mock implementations
- [ ] Создан `internal/domain/tag/handler_test.go`:
  - [ ] Тесты для полного pipeline
  - [ ] Тесты для validation errors
  - [ ] Тесты для execution errors
  - [ ] Тесты для bot response generation
- [ ] Все тесты проходят: `go test ./internal/domain/chat ./internal/domain/tag`
- [ ] Code coverage >80%

## Best Practices

### Table-Driven Tests

```go
tests := []struct {
    name    string
    input   string
    want    string
    wantErr bool
}{
    {"case 1", "input1", "output1", false},
    {"case 2", "input2", "output2", false},
}

for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        // test code
    })
}
```

### Test Helpers

```go
func createTestChat(t *testing.T, chatType chat.Type) *chat.Chat {
    t.Helper()
    // ...
}
```

### Mock Guidelines

1. Use `github.com/stretchr/testify/mock`
2. Create separate mock files or embed in test file
3. Always assert expectations
4. Mock only external dependencies

## Запуск тестов

```bash
# Все тесты
go test ./internal/domain/chat ./internal/domain/tag

# С coverage
go test -cover ./internal/domain/chat ./internal/domain/tag

# Детальный coverage
go test -coverprofile=coverage.out ./internal/domain/chat ./internal/domain/tag
go tool cover -html=coverage.out
```

## Ссылки

- Предыдущая задача: [07.5 - Integration Handler](./07.5-integration-handler.md)
- Existing tests: `internal/domain/tag/processor_test.go`
- Testing docs: Go testing best practices
